import JSZip from 'jszip';
import { saveAs } from 'file-saver';

interface HelmetAssets {
  originalImage: File;
  helmetImageUrl: string;
  faceDepthMapUrl: string | null;
  helmetDepthMapUrl: string | null;
  description: string;
}

export async function generateHelmetZip(assets: HelmetAssets): Promise<void> {
  const zip = new JSZip();
  
  try {
    // Create folders
    const assetsFolder = zip.folder("assets");
    const srcFolder = zip.folder("src");
    
    if (!assetsFolder || !srcFolder) {
      throw new Error("Failed to create zip folders");
    }

    // Add original image
    assetsFolder.file("original-face.jpg", assets.originalImage);

    // Download and add helmet image
    const helmetResponse = await fetch(assets.helmetImageUrl);
    const helmetBlob = await helmetResponse.blob();
    assetsFolder.file("generated-helmet.jpg", helmetBlob);

    // Download and add depth maps if available
    if (assets.faceDepthMapUrl) {
      const faceDepthResponse = await fetch(assets.faceDepthMapUrl);
      const faceDepthBlob = await faceDepthResponse.blob();
      assetsFolder.file("face-depth-map.jpg", faceDepthBlob);
    }

    if (assets.helmetDepthMapUrl) {
      const helmetDepthResponse = await fetch(assets.helmetDepthMapUrl);
      const helmetDepthBlob = await helmetDepthResponse.blob();
      assetsFolder.file("helmet-depth-map.jpg", helmetDepthBlob);
    }

    // Generate HTML file
    const htmlContent = generateHTMLTemplate(assets);
    srcFolder.file("index.html", htmlContent);

    // Generate JavaScript file
    const jsContent = generateJavaScriptCode(assets);
    srcFolder.file("helmet-scene.js", jsContent);

    // Generate CSS file
    const cssContent = generateCSSStyles();
    srcFolder.file("styles.css", cssContent);

    // Generate README
    const readmeContent = generateReadme(assets);
    zip.file("README.md", readmeContent);

    // Generate the zip file
    const zipBlob = await zip.generateAsync({ type: "blob" });
    
    // Download the zip file
    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
    saveAs(zipBlob, `helmet-interactive-${timestamp}.zip`);
    
  } catch (error) {
    console.error('Error generating zip file:', error);
    throw new Error('Failed to generate downloadable package');
  }
}

function generateHTMLTemplate(assets: HelmetAssets): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Helmet - ${assets.description}</title>
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div id="helmet-container">
        <div id="helmet-canvas"></div>
        <div id="instructions">
            <p>Move your cursor around to reveal the helmet with 3D parallax effects</p>
        </div>
    </div>
    
    <script src="helmet-scene.js"></script>
    <script>
        // Initialize the helmet scene when page loads
        window.addEventListener('DOMContentLoaded', () => {
            initHelmetScene({
                container: document.getElementById('helmet-canvas'),
                assets: {
                    faceImage: '../assets/original-face.jpg',
                    helmetImage: '../assets/generated-helmet.jpg',
                    faceDepthMap: ${assets.faceDepthMapUrl ? "'../assets/face-depth-map.jpg'" : 'null'},
                    helmetDepthMap: ${assets.helmetDepthMapUrl ? "'../assets/helmet-depth-map.jpg'" : 'null'}
                }
            });
        });
    </script>
</body>
</html>`;
}

function generateJavaScriptCode(assets: HelmetAssets): string {
  return `// Interactive Helmet Scene
// Generated by Helmet Generator - ${new Date().toISOString()}

function initHelmetScene(config) {
    const container = config.container;
    const assets = config.assets;
    
    if (!container) {
        console.error('Container element not found');
        return;
    }

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);
    
    camera.position.z = 2;
    
    // Mouse tracking
    const mouse = { x: 0, y: 0 };
    const mouseVelocity = { value: 0 };
    let mousePrev = { x: 0, y: 0 };
    
    // Shaders
    const depthParallaxVertexShader = \`
        uniform sampler2D uDepthMap;
        uniform vec2 uMouse;
        uniform float uDepthScale;
        uniform float uTime;
        varying vec2 vUv;
        varying float vDisplacement;

        void main() {
            vUv = uv;
            vec3 pos = position;
            
            if (uDepthScale > 0.0) {
                float depth = texture2D(uDepthMap, uv).r;
                float displacement = depth * uDepthScale;
                
                float parallaxStrength = 0.1;
                pos.x += uMouse.x * displacement * parallaxStrength;
                pos.y += uMouse.y * displacement * parallaxStrength;
                pos.z += displacement * 0.1;
                
                vDisplacement = displacement;
            }
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
    \`;
    
    const depthParallaxFragmentShader = \`
        uniform sampler2D uTexture;
        varying vec2 vUv;
        
        void main() {
            vec4 color = texture2D(uTexture, vUv);
            gl_FragColor = color;
        }
    \`;
    
    const blobMaskVertexShader = \`
        uniform sampler2D uDepthMap;
        uniform vec2 uMouse;
        uniform float uDepthScale;
        varying vec2 vUv;
        varying float vDisplacement;

        void main() {
            vUv = uv;
            vec3 pos = position;
            
            if (uDepthScale > 0.0) {
                float depth = texture2D(uDepthMap, uv).r;
                float displacement = depth * uDepthScale;
                
                float mouseInfluence = 1.0 - distance(uv, vec2(0.5, 0.5)) * 0.5;
                pos.x += uMouse.x * displacement * 0.15 * mouseInfluence;
                pos.y += uMouse.y * displacement * 0.15 * mouseInfluence;
                pos.z += displacement + 0.01;
                
                vDisplacement = displacement;
            }
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
    \`;
    
    const blobMaskFragmentShader = \`
        uniform sampler2D uTexture;
        uniform float uMaskRadius;
        uniform vec2 uMaskCenter;
        uniform float uMaskSoftness;
        uniform float uMouseVelocity;
        varying vec2 vUv;
        
        void main() {
            vec4 color = texture2D(uTexture, vUv);
            
            vec2 toMouse = vUv - uMaskCenter;
            float dist = length(toMouse);
            
            float velocityFactor = clamp(uMouseVelocity * 2.0, 0.5, 3.0);
            float mask = 1.0 - smoothstep(uMaskRadius - uMaskSoftness, uMaskRadius + uMaskSoftness, dist);
            
            color.a *= mask;
            gl_FragColor = color;
        }
    \`;
    
    // Load textures and create meshes
    const textureLoader = new THREE.TextureLoader();
    let faceMesh, helmetMesh;
    
    // Load face texture
    textureLoader.load(assets.faceImage, (faceTexture) => {
        const faceGeometry = new THREE.PlaneGeometry(2, 2, 128, 128);
        
        // Load face depth map if available
        if (assets.faceDepthMap) {
            textureLoader.load(assets.faceDepthMap, (faceDepthTexture) => {
                createFaceMesh(faceGeometry, faceTexture, faceDepthTexture);
            });
        } else {
            createFaceMesh(faceGeometry, faceTexture, null);
        }
    });
    
    // Load helmet texture
    textureLoader.load(assets.helmetImage, (helmetTexture) => {
        const helmetGeometry = new THREE.PlaneGeometry(2, 2, 128, 128);
        
        // Load helmet depth map if available
        if (assets.helmetDepthMap) {
            textureLoader.load(assets.helmetDepthMap, (helmetDepthTexture) => {
                createHelmetMesh(helmetGeometry, helmetTexture, helmetDepthTexture);
            });
        } else {
            createHelmetMesh(helmetGeometry, helmetTexture, null);
        }
    });
    
    function createFaceMesh(geometry, texture, depthTexture) {
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTexture: { value: texture },
                uDepthMap: { value: depthTexture },
                uMouse: { value: new THREE.Vector2(0, 0) },
                uTime: { value: 0 },
                uDepthScale: { value: depthTexture ? 0.1 : 0 }
            },
            vertexShader: depthParallaxVertexShader,
            fragmentShader: depthParallaxFragmentShader
        });
        
        faceMesh = new THREE.Mesh(geometry, material);
        scene.add(faceMesh);
    }
    
    function createHelmetMesh(geometry, texture, depthTexture) {
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTexture: { value: texture },
                uDepthMap: { value: depthTexture },
                uMouse: { value: new THREE.Vector2(0, 0) },
                uTime: { value: 0 },
                uDepthScale: { value: depthTexture ? 0.15 : 0 },
                uMaskRadius: { value: 0.2 },
                uMaskCenter: { value: new THREE.Vector2(0.5, 0.5) },
                uMaskSoftness: { value: 0.1 },
                uMouseVelocity: { value: 0.0 }
            },
            vertexShader: blobMaskVertexShader,
            fragmentShader: blobMaskFragmentShader,
            transparent: true
        });
        
        helmetMesh = new THREE.Mesh(geometry, material);
        scene.add(helmetMesh);
    }
    
    // Mouse tracking
    container.addEventListener('mousemove', (event) => {
        const rect = container.getBoundingClientRect();
        
        mousePrev.x = mouse.x;
        mousePrev.y = mouse.y;
        
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        const dx = mouse.x - mousePrev.x;
        const dy = mouse.y - mousePrev.y;
        mouseVelocity.value = Math.sqrt(dx * dx + dy * dy);
    });
    
    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        
        const time = Date.now() * 0.001;
        
        if (faceMesh && faceMesh.material) {
            faceMesh.material.uniforms.uMouse.value.set(mouse.x, mouse.y);
            faceMesh.material.uniforms.uTime.value = time;
        }
        
        if (helmetMesh && helmetMesh.material) {
            helmetMesh.material.uniforms.uMouse.value.set(mouse.x, mouse.y);
            helmetMesh.material.uniforms.uTime.value = time;
            helmetMesh.material.uniforms.uMouseVelocity.value = mouseVelocity.value;
            
            const baseRadius = 0.2;
            const velocityInfluence = mouseVelocity.value * 10;
            const maskRadius = Math.min(baseRadius + velocityInfluence, 0.9);
            
            helmetMesh.material.uniforms.uMaskRadius.value = maskRadius;
            helmetMesh.material.uniforms.uMaskCenter.value.set(
                (mouse.x + 1) * 0.5,
                (mouse.y + 1) * 0.5
            );
            
            mouseVelocity.value *= 0.95;
        }
        
        renderer.render(scene, camera);
    }
    
    animate();
    
    // Handle resize
    window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });
}`;
}

function generateCSSStyles(): string {
  return `/* Interactive Helmet Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    min-height: 100vh;
    display: flex;
    align-items: center;
    justify-content: center;
}

#helmet-container {
    width: 90vw;
    max-width: 800px;
    height: 60vh;
    min-height: 400px;
    background: rgba(0, 0, 0, 0.9);
    border-radius: 16px;
    padding: 20px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
    position: relative;
    overflow: hidden;
}

#helmet-canvas {
    width: 100%;
    height: calc(100% - 60px);
    cursor: none;
}

#instructions {
    position: absolute;
    bottom: 20px;
    left: 20px;
    right: 20px;
    text-align: center;
    color: white;
    font-size: 14px;
    opacity: 0.8;
}

#instructions p {
    margin: 0;
}

/* Responsive design */
@media (max-width: 768px) {
    #helmet-container {
        width: 95vw;
        height: 70vh;
        padding: 15px;
    }
    
    #instructions {
        font-size: 12px;
        bottom: 15px;
        left: 15px;
        right: 15px;
    }
}`;
}

function generateReadme(assets: HelmetAssets): string {
  return `# Interactive Helmet Experience

Generated on: ${new Date().toLocaleDateString()}
Description: ${assets.description}

## What's Included

This package contains everything you need to embed an interactive 3D helmet experience on your website.

### Files Structure:
\`\`\`
├── README.md                 # This file
├── src/
│   ├── index.html           # Main HTML file
│   ├── helmet-scene.js      # JavaScript for 3D interaction
│   └── styles.css           # CSS styling
└── assets/
    ├── original-face.jpg    # Your original photo
    ├── generated-helmet.jpg # AI-generated helmet
    ${assets.faceDepthMapUrl ? '├── face-depth-map.jpg   # Depth map for face parallax' : ''}
    ${assets.helmetDepthMapUrl ? '└── helmet-depth-map.jpg # Depth map for helmet parallax' : ''}
\`\`\`

## How It Works

- **Move your cursor** around the image to reveal the helmet
- **Depth-based parallax**: Closer parts move more than distant parts
- **Fluid blob masking**: The reveal effect follows your cursor with organic motion
- **Velocity-responsive**: Fast movements create larger reveal areas

## Installation

### Option 1: Standalone HTML
1. Open \`src/index.html\` in your web browser
2. Ensure all files maintain their relative folder structure

### Option 2: Embed in Your Website
1. Copy the \`assets/\` folder to your website's static files
2. Include the Three.js library in your HTML:
   \`\`\`html
   <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
   \`\`\`
3. Add the helmet container to your HTML:
   \`\`\`html
   <div id="helmet-container">
       <div id="helmet-canvas"></div>
   </div>
   \`\`\`
4. Include the CSS and JavaScript files
5. Initialize the scene:
   \`\`\`javascript
   initHelmetScene({
       container: document.getElementById('helmet-canvas'),
       assets: {
           faceImage: 'path/to/original-face.jpg',
           helmetImage: 'path/to/generated-helmet.jpg',
           faceDepthMap: ${assets.faceDepthMapUrl ? "'path/to/face-depth-map.jpg'" : 'null'},
           helmetDepthMap: ${assets.helmetDepthMapUrl ? "'path/to/helmet-depth-map.jpg'" : 'null'}
       }
   });
   \`\`\`

## Browser Compatibility

- **Modern browsers** with WebGL support
- **Chrome 60+**, **Firefox 55+**, **Safari 12+**, **Edge 79+**
- **Mobile browsers** supported (iOS Safari, Chrome Mobile)

## Customization

### Adjust Parallax Strength
In \`helmet-scene.js\`, modify the \`uDepthScale\` values:
- \`0.1\` for face (subtle movement)
- \`0.15\` for helmet (more pronounced movement)

### Change Reveal Size
Modify the \`baseRadius\` value in the animation loop (default: 0.2)

### Performance Optimization
- Reduce geometry resolution by changing \`128, 128\` to \`64, 64\` in PlaneGeometry
- Lower \`devicePixelRatio\` for better performance on high-DPI displays

## Technical Details

- **3D Engine**: Three.js
- **Rendering**: WebGL with custom shaders
- **Depth Maps**: ${assets.faceDepthMapUrl && assets.helmetDepthMapUrl ? 'Both face and helmet depth maps included' : assets.faceDepthMapUrl ? 'Face depth map included' : assets.helmetDepthMapUrl ? 'Helmet depth map included' : 'No depth maps (fallback mode)'}
- **Interactive Elements**: Mouse tracking with velocity detection
- **File Size**: ~${Math.round((assets.originalImage.size || 0) / 1024)}KB total assets

## Support

This interactive helmet was generated using AI technology. For best results:
- Use modern browsers with good WebGL support
- Ensure proper file paths when embedding
- Test on target devices before deployment

---

Generated by [Helmet Generator](https://github.com/your-repo) | Powered by Three.js
`;
}